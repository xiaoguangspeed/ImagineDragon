// // 词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。
// function init() {
//     var name = "Mozilla"; // name 是一个被 init 创建的局部变量
//     function displayName() { // displayName() 是内部函数,一个闭包
//         console.log(name); // 使用了父函数中声明的变量
//     }
//     displayName();
// }
// init();

// //JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。
// function makeFunc() {
//     var name = "Mozilla";
//     function displayName() {
//         console.log(name);
//     }
//     return displayName;
// }

// var myFunc = makeFunc();
// myFunc();
// // ///////////////////////////////////////////////////////////////////////
// function makeAdder(x) {
//     return function(y) {
//       return x + y;
//     };
//   }
  
//   var add5 = makeAdder(5);
//   var add10 = makeAdder(10);
  
//   console.log(add5(2));  // 7
//   console.log(add10(2)); // 12
//   ////////////////////////////////////////////////////////////////////////////////////////////////////
//   var makeCounter = function() {
//     var privateCounter = 0;
//     function changeBy(val) {
//       privateCounter += val;
//     }
//     return {
//       increment: function() {
//         changeBy(1);
//       },
//       decrement: function() {
//         changeBy(-1);
//       },
//       value: function() {
//         return privateCounter;
//       }
//     }  
//   };
// ///////////////////////////重新研究闭包/////////////////////////////////////////////

// for(var i=0;i<5;i++){
//   setTimeout(function(){
//     console.log(new Date(),i)
//   },1000)
// }

for(var i=0;i<5;i++){
  // IIFE（Immediately Invoked Function Expression
  (function(j){
    setTimeout(() => {
      console.log(new Date(),j)
    }, 1000);
  })(i)
}

// for(var i=0;i<5;i++){
//   setTimeout(function(j){
//     console.log(new Date(),j)
//   },1000,i)
// }


console.log(new Date(),i);